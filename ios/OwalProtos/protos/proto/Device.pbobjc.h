// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/device.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_GEN_VERSION != 30001
#error This file was generated by a different version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

@class Camera;
@class Camera_PeerConnector;
@class Camera_Stream;
@class Clip;
@class TimeDelta;
@class TimeStamp;
@class UUID;

NS_ASSUME_NONNULL_BEGIN

#pragma mark - Enum OwalStatus

typedef GPB_ENUM(OwalStatus) {
  /// Value used if any message's field encounters a value that is not defined
  /// by this enum. The message will also have C functions to get/set the rawValue
  /// of the field.
  OwalStatus_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  OwalStatus_CsOk = 0,
  OwalStatus_CsUnautorized = 1,
  OwalStatus_CsUnavailable = 2,
  OwalStatus_CsMissingTimestamp = 3,
};

GPBEnumDescriptor *OwalStatus_EnumDescriptor(void);

/// Checks to see if the given value is defined by the enum or was not known at
/// the time this source was generated.
BOOL OwalStatus_IsValidValue(int32_t value);

#pragma mark - Enum PixelFormat

typedef GPB_ENUM(PixelFormat) {
  /// Value used if any message's field encounters a value that is not defined
  /// by this enum. The message will also have C functions to get/set the rawValue
  /// of the field.
  PixelFormat_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /// most frequently used formats.
  /// These are aliases for the full names.
  PixelFormat_PfNone = 0,
  PixelFormat_PfMjpeg = 194,

  /// From include/linux/videodev2.h
  /// RGB formats
  PixelFormat_V4L2PixFmtRgb332 = 101,
  PixelFormat_V4L2PixFmtRgb444 = 102,
  PixelFormat_V4L2PixFmtArgb444 = 103,
  PixelFormat_V4L2PixFmtXrgb444 = 104,
  PixelFormat_V4L2PixFmtRgb555 = 105,
  PixelFormat_V4L2PixFmtArgb555 = 106,
  PixelFormat_V4L2PixFmtXrgb555 = 107,
  PixelFormat_V4L2PixFmtRgb565 = 108,
  PixelFormat_V4L2PixFmtRgb555X = 109,
  PixelFormat_V4L2PixFmtArgb555X = 110,
  PixelFormat_V4L2PixFmtXrgb555X = 111,
  PixelFormat_V4L2PixFmtRgb565X = 112,
  PixelFormat_V4L2PixFmtBgr666 = 113,
  PixelFormat_V4L2PixFmtBgr24 = 114,
  PixelFormat_V4L2PixFmtRgb24 = 115,
  PixelFormat_V4L2PixFmtBgr32 = 116,
  PixelFormat_V4L2PixFmtAbgr32 = 117,
  PixelFormat_V4L2PixFmtXbgr32 = 118,
  PixelFormat_V4L2PixFmtRgb32 = 119,
  PixelFormat_V4L2PixFmtArgb32 = 120,
  PixelFormat_V4L2PixFmtXrgb32 = 121,

  /// Grey formats
  PixelFormat_V4L2PixFmtGrey = 122,
  PixelFormat_V4L2PixFmtY4 = 123,
  PixelFormat_V4L2PixFmtY6 = 124,
  PixelFormat_V4L2PixFmtY10 = 125,
  PixelFormat_V4L2PixFmtY12 = 126,
  PixelFormat_V4L2PixFmtY16 = 127,
  PixelFormat_V4L2PixFmtY16Be = 128,

  /// Grey bit-packed formats
  PixelFormat_V4L2PixFmtY10Bpack = 129,

  /// Palette formats
  PixelFormat_V4L2PixFmtPal8 = 130,

  /// Chrominance formats
  PixelFormat_V4L2PixFmtUv8 = 131,

  /// Luminance+Chrominance formats
  PixelFormat_V4L2PixFmtYvu410 = 132,
  PixelFormat_V4L2PixFmtYvu420 = 133,
  PixelFormat_V4L2PixFmtYuyv = 134,
  PixelFormat_V4L2PixFmtYyuv = 135,
  PixelFormat_V4L2PixFmtYvyu = 136,
  PixelFormat_V4L2PixFmtUyvy = 137,
  PixelFormat_V4L2PixFmtVyuy = 138,
  PixelFormat_V4L2PixFmtYuv422P = 139,
  PixelFormat_V4L2PixFmtYuv411P = 140,
  PixelFormat_V4L2PixFmtY41P = 141,
  PixelFormat_V4L2PixFmtYuv444 = 142,
  PixelFormat_V4L2PixFmtYuv555 = 143,
  PixelFormat_V4L2PixFmtYuv565 = 144,
  PixelFormat_V4L2PixFmtYuv32 = 145,
  PixelFormat_V4L2PixFmtYuv410 = 146,
  PixelFormat_V4L2PixFmtYuv420 = 147,
  PixelFormat_V4L2PixFmtHi240 = 148,
  PixelFormat_V4L2PixFmtHm12 = 149,
  PixelFormat_V4L2PixFmtM420 = 150,

  /// two planes -- one Y, one Cr + Cb interleaved
  PixelFormat_V4L2PixFmtNv12 = 151,
  PixelFormat_V4L2PixFmtNv21 = 152,
  PixelFormat_V4L2PixFmtNv16 = 153,
  PixelFormat_V4L2PixFmtNv61 = 154,
  PixelFormat_V4L2PixFmtNv24 = 155,
  PixelFormat_V4L2PixFmtNv42 = 156,

  /// two non contiguous planes - one Y, one Cr + Cb interleaved
  PixelFormat_V4L2PixFmtNv12M = 157,
  PixelFormat_V4L2PixFmtNv21M = 158,
  PixelFormat_V4L2PixFmtNv16M = 159,
  PixelFormat_V4L2PixFmtNv61M = 160,
  PixelFormat_V4L2PixFmtNv12Mt = 161,
  PixelFormat_V4L2PixFmtNv12Mt16X16 = 162,

  /// three non contiguous planes - Y, Cb, Cr
  PixelFormat_V4L2PixFmtYuv420M = 163,
  PixelFormat_V4L2PixFmtYvu420M = 164,
  PixelFormat_V4L2PixFmtYuv422M = 165,
  PixelFormat_V4L2PixFmtYvu422M = 166,
  PixelFormat_V4L2PixFmtYuv444M = 167,
  PixelFormat_V4L2PixFmtYvu444M = 168,

  /// Bayer formats - see http://www.siliconimaging.com/RGB%20Bayer.htm
  PixelFormat_V4L2PixFmtSbggr8 = 169,
  PixelFormat_V4L2PixFmtSgbrg8 = 170,
  PixelFormat_V4L2PixFmtSgrbg8 = 171,
  PixelFormat_V4L2PixFmtSrggb8 = 172,
  PixelFormat_V4L2PixFmtSbggr10 = 173,
  PixelFormat_V4L2PixFmtSgbrg10 = 174,
  PixelFormat_V4L2PixFmtSgrbg10 = 175,
  PixelFormat_V4L2PixFmtSrggb10 = 176,

  /// 10bit raw bayer packed, 5 bytes for every 4 pixels
  PixelFormat_V4L2PixFmtSbggr10P = 177,
  PixelFormat_V4L2PixFmtSgbrg10P = 178,
  PixelFormat_V4L2PixFmtSgrbg10P = 179,
  PixelFormat_V4L2PixFmtSrggb10P = 180,

  /// 10bit raw bayer a-law compressed to 8 bits
  PixelFormat_V4L2PixFmtSbggr10Alaw8 = 181,
  PixelFormat_V4L2PixFmtSgbrg10Alaw8 = 182,
  PixelFormat_V4L2PixFmtSgrbg10Alaw8 = 183,
  PixelFormat_V4L2PixFmtSrggb10Alaw8 = 184,

  /// 10bit raw bayer DPCM compressed to 8 bits
  PixelFormat_V4L2PixFmtSbggr10Dpcm8 = 185,
  PixelFormat_V4L2PixFmtSgbrg10Dpcm8 = 186,
  PixelFormat_V4L2PixFmtSgrbg10Dpcm8 = 187,
  PixelFormat_V4L2PixFmtSrggb10Dpcm8 = 188,
  PixelFormat_V4L2PixFmtSbggr12 = 189,
  PixelFormat_V4L2PixFmtSgbrg12 = 190,
  PixelFormat_V4L2PixFmtSgrbg12 = 191,
  PixelFormat_V4L2PixFmtSrggb12 = 192,
  PixelFormat_V4L2PixFmtSbggr16 = 193,

  /// compressed formats
  PixelFormat_V4L2PixFmtMjpeg = 194,
  PixelFormat_V4L2PixFmtJpeg = 195,
  PixelFormat_V4L2PixFmtDv = 196,
  PixelFormat_V4L2PixFmtMpeg = 197,
  PixelFormat_V4L2PixFmtH264 = 198,
  PixelFormat_V4L2PixFmtH264NoSc = 199,
  PixelFormat_V4L2PixFmtH264Mvc = 200,
  PixelFormat_V4L2PixFmtH263 = 201,
  PixelFormat_V4L2PixFmtMpeg1 = 202,
  PixelFormat_V4L2PixFmtMpeg2 = 203,
  PixelFormat_V4L2PixFmtMpeg4 = 204,
  PixelFormat_V4L2PixFmtXvid = 205,
  PixelFormat_V4L2PixFmtVc1AnnexG = 206,
  PixelFormat_V4L2PixFmtVc1AnnexL = 207,
  PixelFormat_V4L2PixFmtVp8 = 208,

  ///  Vendor-specific formats
  PixelFormat_V4L2PixFmtCpia1 = 209,
  PixelFormat_V4L2PixFmtWnva = 210,
  PixelFormat_V4L2PixFmtSn9C10X = 211,
  PixelFormat_V4L2PixFmtSn9C20XI420 = 212,
  PixelFormat_V4L2PixFmtPwc1 = 213,
  PixelFormat_V4L2PixFmtPwc2 = 214,
  PixelFormat_V4L2PixFmtEt61X251 = 215,
  PixelFormat_V4L2PixFmtSpca501 = 216,
  PixelFormat_V4L2PixFmtSpca505 = 217,
  PixelFormat_V4L2PixFmtSpca508 = 218,
  PixelFormat_V4L2PixFmtSpca561 = 219,
  PixelFormat_V4L2PixFmtPac207 = 220,
  PixelFormat_V4L2PixFmtMr97310A = 221,
  PixelFormat_V4L2PixFmtJl2005Bcd = 222,
  PixelFormat_V4L2PixFmtSn9C2028 = 223,
  PixelFormat_V4L2PixFmtSq905C = 224,
  PixelFormat_V4L2PixFmtPjpg = 225,
  PixelFormat_V4L2PixFmtOv511 = 226,
  PixelFormat_V4L2PixFmtOv518 = 227,
  PixelFormat_V4L2PixFmtStv0680 = 228,
  PixelFormat_V4L2PixFmtTm6000 = 229,
  PixelFormat_V4L2PixFmtCitYyvyuy = 230,
  PixelFormat_V4L2PixFmtKonica420 = 231,
  PixelFormat_V4L2PixFmtJpgl = 232,
  PixelFormat_V4L2PixFmtSe401 = 233,
  PixelFormat_V4L2PixFmtS5CUyvyJpg = 234,
  PixelFormat_V4L2PixFmtY8I = 235,
  PixelFormat_V4L2PixFmtY12I = 236,
  PixelFormat_V4L2PixFmtZ16 = 237,

  /// SDR formats - used only for Software Defined Radio devices
  PixelFormat_V4L2SdrFmtCu8 = 238,
  PixelFormat_V4L2SdrFmtCu16Le = 239,
  PixelFormat_V4L2SdrFmtCs8 = 240,
  PixelFormat_V4L2SdrFmtCs14Le = 241,
  PixelFormat_V4L2SdrFmtRu12Le = 242,

  /// priv field value to indicates that subsequent fields are valid.
  PixelFormat_V4L2PixFmtPrivMagic = 243,
};

GPBEnumDescriptor *PixelFormat_EnumDescriptor(void);

/// Checks to see if the given value is defined by the enum or was not known at
/// the time this source was generated.
BOOL PixelFormat_IsValidValue(int32_t value);

#pragma mark - DeviceRoot

/// Exposes the extension registry for this file.
///
/// The base class provides:
/// @code
///   + (GPBExtensionRegistry *)extensionRegistry;
/// @endcode
/// which is a @c GPBExtensionRegistry that includes all the extensions defined by
/// this file and all files that it depends on.
@interface DeviceRoot : GPBRootObject
@end

#pragma mark - Domain

typedef GPB_ENUM(Domain_FieldNumber) {
  Domain_FieldNumber_Id_p = 1,
  Domain_FieldNumber_Description_p = 2,
  Domain_FieldNumber_CamerasArray = 9,
};

@interface Domain : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) UUID *id_p;
/// Test to see if @c id_p has been set.
@property(nonatomic, readwrite) BOOL hasId_p;

@property(nonatomic, readwrite, copy, null_resettable) NSString *description_p;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<UUID*> *camerasArray;
/// The number of items in @c camerasArray without causing the array to be created.
@property(nonatomic, readonly) NSUInteger camerasArray_Count;

@end

#pragma mark - Camera

typedef GPB_ENUM(Camera_FieldNumber) {
  Camera_FieldNumber_Id_p = 1,
  Camera_FieldNumber_Description_p = 2,
  Camera_FieldNumber_Location = 3,
  Camera_FieldNumber_StreamArray = 4,
  Camera_FieldNumber_StreamIndexArray = 5,
  Camera_FieldNumber_PeerArray = 6,
};

@interface Camera : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) UUID *id_p;
/// Test to see if @c id_p has been set.
@property(nonatomic, readwrite) BOOL hasId_p;

@property(nonatomic, readwrite, copy, null_resettable) NSString *description_p;

@property(nonatomic, readwrite, strong, null_resettable) UUID *location;
/// Test to see if @c location has been set.
@property(nonatomic, readwrite) BOOL hasLocation;

/// which streams are configured
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Camera_Stream*> *streamArray;
/// The number of items in @c streamArray without causing the array to be created.
@property(nonatomic, readonly) NSUInteger streamArray_Count;

/// which streams to record
@property(nonatomic, readwrite, strong, null_resettable) GPBInt32Array *streamIndexArray;
/// The number of items in @c streamIndexArray without causing the array to be created.
@property(nonatomic, readonly) NSUInteger streamIndexArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Camera_PeerConnector*> *peerArray;
/// The number of items in @c peerArray without causing the array to be created.
@property(nonatomic, readonly) NSUInteger peerArray_Count;

@end

#pragma mark - Camera_Stream

typedef GPB_ENUM(Camera_Stream_FieldNumber) {
  Camera_Stream_FieldNumber_VideoURL = 1,
  Camera_Stream_FieldNumber_ControlURL = 2,
  Camera_Stream_FieldNumber_Width = 3,
  Camera_Stream_FieldNumber_Height = 4,
  Camera_Stream_FieldNumber_Depth = 5,
  Camera_Stream_FieldNumber_Fps = 6,
  Camera_Stream_FieldNumber_Bps = 7,
  Camera_Stream_FieldNumber_Format = 8,
  Camera_Stream_FieldNumber_Acceptor = 9,
  Camera_Stream_FieldNumber_Authorizer = 10,
  Camera_Stream_FieldNumber_Index = 11,
  Camera_Stream_FieldNumber_S3Bucket = 12,
};

@interface Camera_Stream : GPBMessage

@property(nonatomic, readwrite, copy, null_resettable) NSString *videoURL;

@property(nonatomic, readwrite, copy, null_resettable) NSString *controlURL;

/// pixels
@property(nonatomic, readwrite) int32_t width;

/// pixels
@property(nonatomic, readwrite) int32_t height;

/// bits
@property(nonatomic, readwrite) int32_t depth;

@property(nonatomic, readwrite) int32_t fps;

@property(nonatomic, readwrite) int64_t bps;

@property(nonatomic, readwrite) PixelFormat format;

/// camera listens for incoming connections
@property(nonatomic, readwrite) BOOL acceptor;

/// only needed if acceptor == false
@property(nonatomic, readwrite, strong, null_resettable) UUID *authorizer;
/// Test to see if @c authorizer has been set.
@property(nonatomic, readwrite) BOOL hasAuthorizer;

@property(nonatomic, readwrite) int32_t index;

@property(nonatomic, readwrite, copy, null_resettable) NSString *s3Bucket;

@end

/// Fetches the raw value of a @c Camera_Stream's @c format property, even
/// if the value was not defined by the enum at the time the code was generated.
int32_t Camera_Stream_Format_RawValue(Camera_Stream *message);
/// Sets the raw value of an @c Camera_Stream's @c format property, allowing
/// it to be set to a value that was not defined by the enum at the time the code
/// was generated.
void SetCamera_Stream_Format_RawValue(Camera_Stream *message, int32_t value);

#pragma mark - Camera_PeerConnector

typedef GPB_ENUM(Camera_PeerConnector_FieldNumber) {
  Camera_PeerConnector_FieldNumber_ArrowAngle = 1,
  Camera_PeerConnector_FieldNumber_ArrowX = 2,
  Camera_PeerConnector_FieldNumber_ArrowY = 3,
  Camera_PeerConnector_FieldNumber_Camera = 4,
};

@interface Camera_PeerConnector : GPBMessage

/// degrees CCW (right == 0, up == 90)
@property(nonatomic, readwrite) int32_t arrowAngle;

/// (0 <= x <= 1)
@property(nonatomic, readwrite) float arrowX;

/// (0 <= y <= 1)
@property(nonatomic, readwrite) float arrowY;

@property(nonatomic, readwrite, strong, null_resettable) UUID *camera;
/// Test to see if @c camera has been set.
@property(nonatomic, readwrite) BOOL hasCamera;

@end

#pragma mark - Clip

typedef GPB_ENUM(Clip_FieldNumber) {
  Clip_FieldNumber_Id_p = 1,
  Clip_FieldNumber_Camera = 2,
  Clip_FieldNumber_StreamIndex = 3,
  Clip_FieldNumber_Start = 4,
  Clip_FieldNumber_Duration = 5,
  Clip_FieldNumber_Storage = 10,
  Clip_FieldNumber_KeepUntil = 11,
};

@interface Clip : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) UUID *id_p;
/// Test to see if @c id_p has been set.
@property(nonatomic, readwrite) BOOL hasId_p;

@property(nonatomic, readwrite, strong, null_resettable) UUID *camera;
/// Test to see if @c camera has been set.
@property(nonatomic, readwrite) BOOL hasCamera;

@property(nonatomic, readwrite) int32_t streamIndex;

@property(nonatomic, readwrite, strong, null_resettable) TimeStamp *start;
/// Test to see if @c start has been set.
@property(nonatomic, readwrite) BOOL hasStart;

@property(nonatomic, readwrite, strong, null_resettable) TimeDelta *duration;
/// Test to see if @c duration has been set.
@property(nonatomic, readwrite) BOOL hasDuration;

/// only in response
@property(nonatomic, readwrite, copy, null_resettable) NSString *storage;

/// do not expire before this; e.g., evidence
@property(nonatomic, readwrite, strong, null_resettable) TimeStamp *keepUntil;
/// Test to see if @c keepUntil has been set.
@property(nonatomic, readwrite) BOOL hasKeepUntil;

@end

#pragma mark - CameraRequest

typedef GPB_ENUM(CameraRequest_FieldNumber) {
  CameraRequest_FieldNumber_CameraArray = 1,
  CameraRequest_FieldNumber_Authorizer = 101,
};

@interface CameraRequest : GPBMessage

/// optional
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<UUID*> *cameraArray;
/// The number of items in @c cameraArray without causing the array to be created.
@property(nonatomic, readonly) NSUInteger cameraArray_Count;

/// TODO(ji): Specify additional selectors.
@property(nonatomic, readwrite, strong, null_resettable) UUID *authorizer;
/// Test to see if @c authorizer has been set.
@property(nonatomic, readwrite) BOOL hasAuthorizer;

@end

#pragma mark - CameraResponse

typedef GPB_ENUM(CameraResponse_FieldNumber) {
  CameraResponse_FieldNumber_CameraArray = 1,
  CameraResponse_FieldNumber_Status = 2,
};

@interface CameraResponse : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Camera*> *cameraArray;
/// The number of items in @c cameraArray without causing the array to be created.
@property(nonatomic, readonly) NSUInteger cameraArray_Count;

@property(nonatomic, readwrite) OwalStatus status;

@end

/// Fetches the raw value of a @c CameraResponse's @c status property, even
/// if the value was not defined by the enum at the time the code was generated.
int32_t CameraResponse_Status_RawValue(CameraResponse *message);
/// Sets the raw value of an @c CameraResponse's @c status property, allowing
/// it to be set to a value that was not defined by the enum at the time the code
/// was generated.
void SetCameraResponse_Status_RawValue(CameraResponse *message, int32_t value);

#pragma mark - ClipRequest

typedef GPB_ENUM(ClipRequest_FieldNumber) {
  ClipRequest_FieldNumber_Camera = 1,
  ClipRequest_FieldNumber_First = 2,
  ClipRequest_FieldNumber_Duration = 3,
  ClipRequest_FieldNumber_Authorizer = 101,
};

@interface ClipRequest : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) UUID *camera;
/// Test to see if @c camera has been set.
@property(nonatomic, readwrite) BOOL hasCamera;

/// missing => beginning of time
@property(nonatomic, readwrite, strong, null_resettable) TimeStamp *first;
/// Test to see if @c first has been set.
@property(nonatomic, readwrite) BOOL hasFirst;

/// missing => now - first
@property(nonatomic, readwrite, strong, null_resettable) TimeDelta *duration;
/// Test to see if @c duration has been set.
@property(nonatomic, readwrite) BOOL hasDuration;

@property(nonatomic, readwrite, strong, null_resettable) UUID *authorizer;
/// Test to see if @c authorizer has been set.
@property(nonatomic, readwrite) BOOL hasAuthorizer;

@end

#pragma mark - ClipResponse

typedef GPB_ENUM(ClipResponse_FieldNumber) {
  ClipResponse_FieldNumber_ClipArray = 1,
  ClipResponse_FieldNumber_Status = 2,
};

@interface ClipResponse : GPBMessage

/// TODO(ji): Figure out streaming
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Clip*> *clipArray;
/// The number of items in @c clipArray without causing the array to be created.
@property(nonatomic, readonly) NSUInteger clipArray_Count;

@property(nonatomic, readwrite) OwalStatus status;

@end

/// Fetches the raw value of a @c ClipResponse's @c status property, even
/// if the value was not defined by the enum at the time the code was generated.
int32_t ClipResponse_Status_RawValue(ClipResponse *message);
/// Sets the raw value of an @c ClipResponse's @c status property, allowing
/// it to be set to a value that was not defined by the enum at the time the code
/// was generated.
void SetClipResponse_Status_RawValue(ClipResponse *message, int32_t value);

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
