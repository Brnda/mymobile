// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/device.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "proto/Device.pbobjc.h"
 #import "proto/Types.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - DeviceRoot

@implementation DeviceRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[TypesRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - DeviceRoot_FileDescriptor

static GPBFileDescriptor *DeviceRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"owal"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum OwalStatus

GPBEnumDescriptor *OwalStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "CsOk\000CsUnautorized\000CsUnavailable\000CsMissi"
        "ngTimestamp\000";
    static const int32_t values[] = {
        OwalStatus_CsOk,
        OwalStatus_CsUnautorized,
        OwalStatus_CsUnavailable,
        OwalStatus_CsMissingTimestamp,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OwalStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OwalStatus_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OwalStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case OwalStatus_CsOk:
    case OwalStatus_CsUnautorized:
    case OwalStatus_CsUnavailable:
    case OwalStatus_CsMissingTimestamp:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PixelFormat

GPBEnumDescriptor *PixelFormat_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "PfNone\000PfMjpeg\000V4L2PixFmtRgb332\000V4L2PixF"
        "mtRgb444\000V4L2PixFmtArgb444\000V4L2PixFmtXrg"
        "b444\000V4L2PixFmtRgb555\000V4L2PixFmtArgb555\000"
        "V4L2PixFmtXrgb555\000V4L2PixFmtRgb565\000V4L2P"
        "ixFmtRgb555X\000V4L2PixFmtArgb555X\000V4L2PixF"
        "mtXrgb555X\000V4L2PixFmtRgb565X\000V4L2PixFmtB"
        "gr666\000V4L2PixFmtBgr24\000V4L2PixFmtRgb24\000V4"
        "L2PixFmtBgr32\000V4L2PixFmtAbgr32\000V4L2PixFm"
        "tXbgr32\000V4L2PixFmtRgb32\000V4L2PixFmtArgb32"
        "\000V4L2PixFmtXrgb32\000V4L2PixFmtGrey\000V4L2Pix"
        "FmtY4\000V4L2PixFmtY6\000V4L2PixFmtY10\000V4L2Pix"
        "FmtY12\000V4L2PixFmtY16\000V4L2PixFmtY16Be\000V4L"
        "2PixFmtY10Bpack\000V4L2PixFmtPal8\000V4L2PixFm"
        "tUv8\000V4L2PixFmtYvu410\000V4L2PixFmtYvu420\000V"
        "4L2PixFmtYuyv\000V4L2PixFmtYyuv\000V4L2PixFmtY"
        "vyu\000V4L2PixFmtUyvy\000V4L2PixFmtVyuy\000V4L2Pi"
        "xFmtYuv422P\000V4L2PixFmtYuv411P\000V4L2PixFmt"
        "Y41P\000V4L2PixFmtYuv444\000V4L2PixFmtYuv555\000V"
        "4L2PixFmtYuv565\000V4L2PixFmtYuv32\000V4L2PixF"
        "mtYuv410\000V4L2PixFmtYuv420\000V4L2PixFmtHi24"
        "0\000V4L2PixFmtHm12\000V4L2PixFmtM420\000V4L2PixF"
        "mtNv12\000V4L2PixFmtNv21\000V4L2PixFmtNv16\000V4L"
        "2PixFmtNv61\000V4L2PixFmtNv24\000V4L2PixFmtNv4"
        "2\000V4L2PixFmtNv12M\000V4L2PixFmtNv21M\000V4L2Pi"
        "xFmtNv16M\000V4L2PixFmtNv61M\000V4L2PixFmtNv12"
        "Mt\000V4L2PixFmtNv12Mt16X16\000V4L2PixFmtYuv42"
        "0M\000V4L2PixFmtYvu420M\000V4L2PixFmtYuv422M\000V"
        "4L2PixFmtYvu422M\000V4L2PixFmtYuv444M\000V4L2P"
        "ixFmtYvu444M\000V4L2PixFmtSbggr8\000V4L2PixFmt"
        "Sgbrg8\000V4L2PixFmtSgrbg8\000V4L2PixFmtSrggb8"
        "\000V4L2PixFmtSbggr10\000V4L2PixFmtSgbrg10\000V4L"
        "2PixFmtSgrbg10\000V4L2PixFmtSrggb10\000V4L2Pix"
        "FmtSbggr10P\000V4L2PixFmtSgbrg10P\000V4L2PixFm"
        "tSgrbg10P\000V4L2PixFmtSrggb10P\000V4L2PixFmtS"
        "bggr10Alaw8\000V4L2PixFmtSgbrg10Alaw8\000V4L2P"
        "ixFmtSgrbg10Alaw8\000V4L2PixFmtSrggb10Alaw8"
        "\000V4L2PixFmtSbggr10Dpcm8\000V4L2PixFmtSgbrg1"
        "0Dpcm8\000V4L2PixFmtSgrbg10Dpcm8\000V4L2PixFmt"
        "Srggb10Dpcm8\000V4L2PixFmtSbggr12\000V4L2PixFm"
        "tSgbrg12\000V4L2PixFmtSgrbg12\000V4L2PixFmtSrg"
        "gb12\000V4L2PixFmtSbggr16\000V4L2PixFmtMjpeg\000V"
        "4L2PixFmtJpeg\000V4L2PixFmtDv\000V4L2PixFmtMpe"
        "g\000V4L2PixFmtH264\000V4L2PixFmtH264NoSc\000V4L2"
        "PixFmtH264Mvc\000V4L2PixFmtH263\000V4L2PixFmtM"
        "peg1\000V4L2PixFmtMpeg2\000V4L2PixFmtMpeg4\000V4L"
        "2PixFmtXvid\000V4L2PixFmtVc1AnnexG\000V4L2PixF"
        "mtVc1AnnexL\000V4L2PixFmtVp8\000V4L2PixFmtCpia"
        "1\000V4L2PixFmtWnva\000V4L2PixFmtSn9C10X\000V4L2P"
        "ixFmtSn9C20XI420\000V4L2PixFmtPwc1\000V4L2PixF"
        "mtPwc2\000V4L2PixFmtEt61X251\000V4L2PixFmtSpca"
        "501\000V4L2PixFmtSpca505\000V4L2PixFmtSpca508\000"
        "V4L2PixFmtSpca561\000V4L2PixFmtPac207\000V4L2P"
        "ixFmtMr97310A\000V4L2PixFmtJl2005Bcd\000V4L2Pi"
        "xFmtSn9C2028\000V4L2PixFmtSq905C\000V4L2PixFmt"
        "Pjpg\000V4L2PixFmtOv511\000V4L2PixFmtOv518\000V4L"
        "2PixFmtStv0680\000V4L2PixFmtTm6000\000V4L2PixF"
        "mtCitYyvyuy\000V4L2PixFmtKonica420\000V4L2PixF"
        "mtJpgl\000V4L2PixFmtSe401\000V4L2PixFmtS5CUyvy"
        "Jpg\000V4L2PixFmtY8I\000V4L2PixFmtY12I\000V4L2Pix"
        "FmtZ16\000V4L2SdrFmtCu8\000V4L2SdrFmtCu16Le\000V4"
        "L2SdrFmtCs8\000V4L2SdrFmtCs14Le\000V4L2SdrFmtR"
        "u12Le\000V4L2PixFmtPrivMagic\000";
    static const int32_t values[] = {
        PixelFormat_PfNone,
        PixelFormat_PfMjpeg,
        PixelFormat_V4L2PixFmtRgb332,
        PixelFormat_V4L2PixFmtRgb444,
        PixelFormat_V4L2PixFmtArgb444,
        PixelFormat_V4L2PixFmtXrgb444,
        PixelFormat_V4L2PixFmtRgb555,
        PixelFormat_V4L2PixFmtArgb555,
        PixelFormat_V4L2PixFmtXrgb555,
        PixelFormat_V4L2PixFmtRgb565,
        PixelFormat_V4L2PixFmtRgb555X,
        PixelFormat_V4L2PixFmtArgb555X,
        PixelFormat_V4L2PixFmtXrgb555X,
        PixelFormat_V4L2PixFmtRgb565X,
        PixelFormat_V4L2PixFmtBgr666,
        PixelFormat_V4L2PixFmtBgr24,
        PixelFormat_V4L2PixFmtRgb24,
        PixelFormat_V4L2PixFmtBgr32,
        PixelFormat_V4L2PixFmtAbgr32,
        PixelFormat_V4L2PixFmtXbgr32,
        PixelFormat_V4L2PixFmtRgb32,
        PixelFormat_V4L2PixFmtArgb32,
        PixelFormat_V4L2PixFmtXrgb32,
        PixelFormat_V4L2PixFmtGrey,
        PixelFormat_V4L2PixFmtY4,
        PixelFormat_V4L2PixFmtY6,
        PixelFormat_V4L2PixFmtY10,
        PixelFormat_V4L2PixFmtY12,
        PixelFormat_V4L2PixFmtY16,
        PixelFormat_V4L2PixFmtY16Be,
        PixelFormat_V4L2PixFmtY10Bpack,
        PixelFormat_V4L2PixFmtPal8,
        PixelFormat_V4L2PixFmtUv8,
        PixelFormat_V4L2PixFmtYvu410,
        PixelFormat_V4L2PixFmtYvu420,
        PixelFormat_V4L2PixFmtYuyv,
        PixelFormat_V4L2PixFmtYyuv,
        PixelFormat_V4L2PixFmtYvyu,
        PixelFormat_V4L2PixFmtUyvy,
        PixelFormat_V4L2PixFmtVyuy,
        PixelFormat_V4L2PixFmtYuv422P,
        PixelFormat_V4L2PixFmtYuv411P,
        PixelFormat_V4L2PixFmtY41P,
        PixelFormat_V4L2PixFmtYuv444,
        PixelFormat_V4L2PixFmtYuv555,
        PixelFormat_V4L2PixFmtYuv565,
        PixelFormat_V4L2PixFmtYuv32,
        PixelFormat_V4L2PixFmtYuv410,
        PixelFormat_V4L2PixFmtYuv420,
        PixelFormat_V4L2PixFmtHi240,
        PixelFormat_V4L2PixFmtHm12,
        PixelFormat_V4L2PixFmtM420,
        PixelFormat_V4L2PixFmtNv12,
        PixelFormat_V4L2PixFmtNv21,
        PixelFormat_V4L2PixFmtNv16,
        PixelFormat_V4L2PixFmtNv61,
        PixelFormat_V4L2PixFmtNv24,
        PixelFormat_V4L2PixFmtNv42,
        PixelFormat_V4L2PixFmtNv12M,
        PixelFormat_V4L2PixFmtNv21M,
        PixelFormat_V4L2PixFmtNv16M,
        PixelFormat_V4L2PixFmtNv61M,
        PixelFormat_V4L2PixFmtNv12Mt,
        PixelFormat_V4L2PixFmtNv12Mt16X16,
        PixelFormat_V4L2PixFmtYuv420M,
        PixelFormat_V4L2PixFmtYvu420M,
        PixelFormat_V4L2PixFmtYuv422M,
        PixelFormat_V4L2PixFmtYvu422M,
        PixelFormat_V4L2PixFmtYuv444M,
        PixelFormat_V4L2PixFmtYvu444M,
        PixelFormat_V4L2PixFmtSbggr8,
        PixelFormat_V4L2PixFmtSgbrg8,
        PixelFormat_V4L2PixFmtSgrbg8,
        PixelFormat_V4L2PixFmtSrggb8,
        PixelFormat_V4L2PixFmtSbggr10,
        PixelFormat_V4L2PixFmtSgbrg10,
        PixelFormat_V4L2PixFmtSgrbg10,
        PixelFormat_V4L2PixFmtSrggb10,
        PixelFormat_V4L2PixFmtSbggr10P,
        PixelFormat_V4L2PixFmtSgbrg10P,
        PixelFormat_V4L2PixFmtSgrbg10P,
        PixelFormat_V4L2PixFmtSrggb10P,
        PixelFormat_V4L2PixFmtSbggr10Alaw8,
        PixelFormat_V4L2PixFmtSgbrg10Alaw8,
        PixelFormat_V4L2PixFmtSgrbg10Alaw8,
        PixelFormat_V4L2PixFmtSrggb10Alaw8,
        PixelFormat_V4L2PixFmtSbggr10Dpcm8,
        PixelFormat_V4L2PixFmtSgbrg10Dpcm8,
        PixelFormat_V4L2PixFmtSgrbg10Dpcm8,
        PixelFormat_V4L2PixFmtSrggb10Dpcm8,
        PixelFormat_V4L2PixFmtSbggr12,
        PixelFormat_V4L2PixFmtSgbrg12,
        PixelFormat_V4L2PixFmtSgrbg12,
        PixelFormat_V4L2PixFmtSrggb12,
        PixelFormat_V4L2PixFmtSbggr16,
        PixelFormat_V4L2PixFmtMjpeg,
        PixelFormat_V4L2PixFmtJpeg,
        PixelFormat_V4L2PixFmtDv,
        PixelFormat_V4L2PixFmtMpeg,
        PixelFormat_V4L2PixFmtH264,
        PixelFormat_V4L2PixFmtH264NoSc,
        PixelFormat_V4L2PixFmtH264Mvc,
        PixelFormat_V4L2PixFmtH263,
        PixelFormat_V4L2PixFmtMpeg1,
        PixelFormat_V4L2PixFmtMpeg2,
        PixelFormat_V4L2PixFmtMpeg4,
        PixelFormat_V4L2PixFmtXvid,
        PixelFormat_V4L2PixFmtVc1AnnexG,
        PixelFormat_V4L2PixFmtVc1AnnexL,
        PixelFormat_V4L2PixFmtVp8,
        PixelFormat_V4L2PixFmtCpia1,
        PixelFormat_V4L2PixFmtWnva,
        PixelFormat_V4L2PixFmtSn9C10X,
        PixelFormat_V4L2PixFmtSn9C20XI420,
        PixelFormat_V4L2PixFmtPwc1,
        PixelFormat_V4L2PixFmtPwc2,
        PixelFormat_V4L2PixFmtEt61X251,
        PixelFormat_V4L2PixFmtSpca501,
        PixelFormat_V4L2PixFmtSpca505,
        PixelFormat_V4L2PixFmtSpca508,
        PixelFormat_V4L2PixFmtSpca561,
        PixelFormat_V4L2PixFmtPac207,
        PixelFormat_V4L2PixFmtMr97310A,
        PixelFormat_V4L2PixFmtJl2005Bcd,
        PixelFormat_V4L2PixFmtSn9C2028,
        PixelFormat_V4L2PixFmtSq905C,
        PixelFormat_V4L2PixFmtPjpg,
        PixelFormat_V4L2PixFmtOv511,
        PixelFormat_V4L2PixFmtOv518,
        PixelFormat_V4L2PixFmtStv0680,
        PixelFormat_V4L2PixFmtTm6000,
        PixelFormat_V4L2PixFmtCitYyvyuy,
        PixelFormat_V4L2PixFmtKonica420,
        PixelFormat_V4L2PixFmtJpgl,
        PixelFormat_V4L2PixFmtSe401,
        PixelFormat_V4L2PixFmtS5CUyvyJpg,
        PixelFormat_V4L2PixFmtY8I,
        PixelFormat_V4L2PixFmtY12I,
        PixelFormat_V4L2PixFmtZ16,
        PixelFormat_V4L2SdrFmtCu8,
        PixelFormat_V4L2SdrFmtCu16Le,
        PixelFormat_V4L2SdrFmtCs8,
        PixelFormat_V4L2SdrFmtCs14Le,
        PixelFormat_V4L2SdrFmtRu12Le,
        PixelFormat_V4L2PixFmtPrivMagic,
    };
    static const char *extraTextFormatInfo = "\217\001\002\004\343\343\343\003\000\003\004\343\343\343\003\000\004\004\343\343\344\003\000\005\004\343\343\344\003\000\006\004\343\343\343\003\000\007\004\343\343\344\003\000\010\004\343\343\344\003\000\t\004\343\343\343\003\000\n\004\343\343\343\004\000\013\004\343\343\344\004\000\014\004\343\343\344\004\000\r\004\343\343\343\004\000\016\004\343\343\343\003\000\017\004\343\343\343\002\000\020\004\343\343\343\002\000\021\004\343\343\343\002\000\022\004\343\343\344\002\000\023\004\343\343\344\002\000\024\004\343\343\343\002\000\025\004\343\343\344\002\000\026\004\343\343\344\002\000\027\004\343\343\344\000\030\004\343\343\202\000\031\004\343\343\202\000\032\004\343\343\203\000\033\004\343\343\203\000\034\004\343\343\203\000\035\004\343\343\203\342\000\036\004\343\343\204d\000\037\004\343\343\343\001\000 \004\343\343\342\001\000!\004\343\343\343\003\000\"\004\343\343\343\003\000#\004\343\343\344\000$\004\343\343\344\000%\004\343\343\344\000&\004\343\343\344\000\'\004\343\343\344\000(\004\343\343\343\004\000)\004\343\343\343\004\000*\004\343\343\204\000+\004\343\343\343\003\000,\004\343\343\343\003\000-\004\343\343\343\003\000.\004\343\343\343\002\000/\004\343\343\343\003\0000\004\343\343\343\003\0001\004\343\343\342\003\0002\004\343\343\342\002\0003\004\343\343\204\0004\004\343\343\342\002\0005\004\343\343\342\002\0006\004\343\343\342\002\0007\004\343\343\342\002\0008\004\343\343\342\002\0009\004\343\343\342\002\000:\004\343\343\342\003\000;\004\343\343\342\003\000<\004\343\343\342\003\000=\004\343\343\342\003\000>\004\343\343\342\003A\000?\004\343\343\342\003A\205\000@\004\343\343\343\004\000A\004\343\343\343\004\000B\004\343\343\343\004\000C\004\343\343\343\004\000D\004\343\343\343\004\000E\004\343\343\343\004\000F\004\343\343\345\001\000G\004\343\343\345\001\000H\004\343\343\345\001\000I\004\343\343\345\001\000J\004\343\343\345\002\000K\004\343\343\345\002\000L\004\343\343\345\002\000M\004\343\343\345\002\000N\004\343\343\345\003\000O\004\343\343\345\003\000P\004\343\343\345\003\000Q\004\343\343\345\003\000R\004\343\343\345\003c\001\000S\004\343\343\345\003c\001\000T\004\343\343\345\003c\001\000U\004\343\343\345\003c\001\000V\004\343\343\345\003c\001\000W\004\343\343\345\003c\001\000X\004\343\343\345\003c\001\000Y\004\343\343\345\003c\001\000Z\004\343\343\345\002\000[\004\343\343\345\002\000\\\004\343\343\345\002\000]\004\343\343\345\002\000^\004\343\343\345\002\000_\004\343\343\345\000`\004\343\343\344\000a\004\343\343\342\000b\004\343\343\344\000c\004\343\343\204\000d\004\343\343\204\342\342\000e\004\343\343\204\343\000f\004\343\343\204\000g\004\343\343\344\001\000h\004\343\343\344\001\000i\004\343\343\344\001\000j\004\343\343\344\000k\004\343\343\342\001\345\201\000l\004\343\343\342\001\345\201\000m\004\343\343\342\001\000n\004\343\343\344\001\000o\004\343\343\344\000p\004\343\343\342\005\000q\004\343\343\342\005\204\000r\004\343\343\343\001\000s\004\343\343\343\001\000t\004\343\343\342\006\000u\004\343\343\344\003\000v\004\343\343\344\003\000w\004\343\343\344\003\000x\004\343\343\344\003\000y\004\343\343\343\003\000z\004\343\343\342\006\000{\004\343\343\342\005b\000|\004\343\343\342\006\000}\004\343\343\342\004\000~\004\343\343\344\000\177\004\343\343\342\003\000\200\001\004\343\343\342\003\000\201\001\004\343\343\343\004\000\202\001\004\343\343\342\004\000\203\001\004\343\343\343\346\000\204\001\004\343\343\346\003\000\205\001\004\343\343\344\000\206\001\004\343\343\342\003\000\207\001\004\343\343\203\344\343\000\210\001\004\343\343\203\000\211\001\004\343\343\204\000\212\001\004\343\343\203\000\213\001\004\343\343\342\001\000\214\001\004\343\343\342\003A\000\215\001\004\343\343\342\001\000\216\001\004\343\343\342\003A\000\217\001\004\343\343\342\003A\000\220\001\004\343\343\344\345\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PixelFormat)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PixelFormat_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PixelFormat_IsValidValue(int32_t value__) {
  switch (value__) {
    case PixelFormat_PfNone:
    case PixelFormat_PfMjpeg:
    case PixelFormat_V4L2PixFmtRgb332:
    case PixelFormat_V4L2PixFmtRgb444:
    case PixelFormat_V4L2PixFmtArgb444:
    case PixelFormat_V4L2PixFmtXrgb444:
    case PixelFormat_V4L2PixFmtRgb555:
    case PixelFormat_V4L2PixFmtArgb555:
    case PixelFormat_V4L2PixFmtXrgb555:
    case PixelFormat_V4L2PixFmtRgb565:
    case PixelFormat_V4L2PixFmtRgb555X:
    case PixelFormat_V4L2PixFmtArgb555X:
    case PixelFormat_V4L2PixFmtXrgb555X:
    case PixelFormat_V4L2PixFmtRgb565X:
    case PixelFormat_V4L2PixFmtBgr666:
    case PixelFormat_V4L2PixFmtBgr24:
    case PixelFormat_V4L2PixFmtRgb24:
    case PixelFormat_V4L2PixFmtBgr32:
    case PixelFormat_V4L2PixFmtAbgr32:
    case PixelFormat_V4L2PixFmtXbgr32:
    case PixelFormat_V4L2PixFmtRgb32:
    case PixelFormat_V4L2PixFmtArgb32:
    case PixelFormat_V4L2PixFmtXrgb32:
    case PixelFormat_V4L2PixFmtGrey:
    case PixelFormat_V4L2PixFmtY4:
    case PixelFormat_V4L2PixFmtY6:
    case PixelFormat_V4L2PixFmtY10:
    case PixelFormat_V4L2PixFmtY12:
    case PixelFormat_V4L2PixFmtY16:
    case PixelFormat_V4L2PixFmtY16Be:
    case PixelFormat_V4L2PixFmtY10Bpack:
    case PixelFormat_V4L2PixFmtPal8:
    case PixelFormat_V4L2PixFmtUv8:
    case PixelFormat_V4L2PixFmtYvu410:
    case PixelFormat_V4L2PixFmtYvu420:
    case PixelFormat_V4L2PixFmtYuyv:
    case PixelFormat_V4L2PixFmtYyuv:
    case PixelFormat_V4L2PixFmtYvyu:
    case PixelFormat_V4L2PixFmtUyvy:
    case PixelFormat_V4L2PixFmtVyuy:
    case PixelFormat_V4L2PixFmtYuv422P:
    case PixelFormat_V4L2PixFmtYuv411P:
    case PixelFormat_V4L2PixFmtY41P:
    case PixelFormat_V4L2PixFmtYuv444:
    case PixelFormat_V4L2PixFmtYuv555:
    case PixelFormat_V4L2PixFmtYuv565:
    case PixelFormat_V4L2PixFmtYuv32:
    case PixelFormat_V4L2PixFmtYuv410:
    case PixelFormat_V4L2PixFmtYuv420:
    case PixelFormat_V4L2PixFmtHi240:
    case PixelFormat_V4L2PixFmtHm12:
    case PixelFormat_V4L2PixFmtM420:
    case PixelFormat_V4L2PixFmtNv12:
    case PixelFormat_V4L2PixFmtNv21:
    case PixelFormat_V4L2PixFmtNv16:
    case PixelFormat_V4L2PixFmtNv61:
    case PixelFormat_V4L2PixFmtNv24:
    case PixelFormat_V4L2PixFmtNv42:
    case PixelFormat_V4L2PixFmtNv12M:
    case PixelFormat_V4L2PixFmtNv21M:
    case PixelFormat_V4L2PixFmtNv16M:
    case PixelFormat_V4L2PixFmtNv61M:
    case PixelFormat_V4L2PixFmtNv12Mt:
    case PixelFormat_V4L2PixFmtNv12Mt16X16:
    case PixelFormat_V4L2PixFmtYuv420M:
    case PixelFormat_V4L2PixFmtYvu420M:
    case PixelFormat_V4L2PixFmtYuv422M:
    case PixelFormat_V4L2PixFmtYvu422M:
    case PixelFormat_V4L2PixFmtYuv444M:
    case PixelFormat_V4L2PixFmtYvu444M:
    case PixelFormat_V4L2PixFmtSbggr8:
    case PixelFormat_V4L2PixFmtSgbrg8:
    case PixelFormat_V4L2PixFmtSgrbg8:
    case PixelFormat_V4L2PixFmtSrggb8:
    case PixelFormat_V4L2PixFmtSbggr10:
    case PixelFormat_V4L2PixFmtSgbrg10:
    case PixelFormat_V4L2PixFmtSgrbg10:
    case PixelFormat_V4L2PixFmtSrggb10:
    case PixelFormat_V4L2PixFmtSbggr10P:
    case PixelFormat_V4L2PixFmtSgbrg10P:
    case PixelFormat_V4L2PixFmtSgrbg10P:
    case PixelFormat_V4L2PixFmtSrggb10P:
    case PixelFormat_V4L2PixFmtSbggr10Alaw8:
    case PixelFormat_V4L2PixFmtSgbrg10Alaw8:
    case PixelFormat_V4L2PixFmtSgrbg10Alaw8:
    case PixelFormat_V4L2PixFmtSrggb10Alaw8:
    case PixelFormat_V4L2PixFmtSbggr10Dpcm8:
    case PixelFormat_V4L2PixFmtSgbrg10Dpcm8:
    case PixelFormat_V4L2PixFmtSgrbg10Dpcm8:
    case PixelFormat_V4L2PixFmtSrggb10Dpcm8:
    case PixelFormat_V4L2PixFmtSbggr12:
    case PixelFormat_V4L2PixFmtSgbrg12:
    case PixelFormat_V4L2PixFmtSgrbg12:
    case PixelFormat_V4L2PixFmtSrggb12:
    case PixelFormat_V4L2PixFmtSbggr16:
    case PixelFormat_V4L2PixFmtJpeg:
    case PixelFormat_V4L2PixFmtDv:
    case PixelFormat_V4L2PixFmtMpeg:
    case PixelFormat_V4L2PixFmtH264:
    case PixelFormat_V4L2PixFmtH264NoSc:
    case PixelFormat_V4L2PixFmtH264Mvc:
    case PixelFormat_V4L2PixFmtH263:
    case PixelFormat_V4L2PixFmtMpeg1:
    case PixelFormat_V4L2PixFmtMpeg2:
    case PixelFormat_V4L2PixFmtMpeg4:
    case PixelFormat_V4L2PixFmtXvid:
    case PixelFormat_V4L2PixFmtVc1AnnexG:
    case PixelFormat_V4L2PixFmtVc1AnnexL:
    case PixelFormat_V4L2PixFmtVp8:
    case PixelFormat_V4L2PixFmtCpia1:
    case PixelFormat_V4L2PixFmtWnva:
    case PixelFormat_V4L2PixFmtSn9C10X:
    case PixelFormat_V4L2PixFmtSn9C20XI420:
    case PixelFormat_V4L2PixFmtPwc1:
    case PixelFormat_V4L2PixFmtPwc2:
    case PixelFormat_V4L2PixFmtEt61X251:
    case PixelFormat_V4L2PixFmtSpca501:
    case PixelFormat_V4L2PixFmtSpca505:
    case PixelFormat_V4L2PixFmtSpca508:
    case PixelFormat_V4L2PixFmtSpca561:
    case PixelFormat_V4L2PixFmtPac207:
    case PixelFormat_V4L2PixFmtMr97310A:
    case PixelFormat_V4L2PixFmtJl2005Bcd:
    case PixelFormat_V4L2PixFmtSn9C2028:
    case PixelFormat_V4L2PixFmtSq905C:
    case PixelFormat_V4L2PixFmtPjpg:
    case PixelFormat_V4L2PixFmtOv511:
    case PixelFormat_V4L2PixFmtOv518:
    case PixelFormat_V4L2PixFmtStv0680:
    case PixelFormat_V4L2PixFmtTm6000:
    case PixelFormat_V4L2PixFmtCitYyvyuy:
    case PixelFormat_V4L2PixFmtKonica420:
    case PixelFormat_V4L2PixFmtJpgl:
    case PixelFormat_V4L2PixFmtSe401:
    case PixelFormat_V4L2PixFmtS5CUyvyJpg:
    case PixelFormat_V4L2PixFmtY8I:
    case PixelFormat_V4L2PixFmtY12I:
    case PixelFormat_V4L2PixFmtZ16:
    case PixelFormat_V4L2SdrFmtCu8:
    case PixelFormat_V4L2SdrFmtCu16Le:
    case PixelFormat_V4L2SdrFmtCs8:
    case PixelFormat_V4L2SdrFmtCs14Le:
    case PixelFormat_V4L2SdrFmtRu12Le:
    case PixelFormat_V4L2PixFmtPrivMagic:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Domain

@implementation Domain

@dynamic hasId_p, id_p;
@dynamic description_p;
@dynamic camerasArray, camerasArray_Count;

typedef struct Domain__storage_ {
  uint32_t _has_storage_[1];
  UUID *id_p;
  NSString *description_p;
  NSMutableArray *camerasArray;
} Domain__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = GPBStringifySymbol(UUID),
        .number = Domain_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Domain__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = Domain_FieldNumber_Description_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Domain__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "camerasArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UUID),
        .number = Domain_FieldNumber_CamerasArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Domain__storage_, camerasArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Domain class]
                                     rootClass:[DeviceRoot class]
                                          file:DeviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Domain__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Camera

@implementation Camera

@dynamic hasId_p, id_p;
@dynamic description_p;
@dynamic hasLocation, location;
@dynamic streamArray, streamArray_Count;
@dynamic streamIndexArray, streamIndexArray_Count;
@dynamic peerArray, peerArray_Count;

typedef struct Camera__storage_ {
  uint32_t _has_storage_[1];
  UUID *id_p;
  NSString *description_p;
  UUID *location;
  NSMutableArray *streamArray;
  GPBInt32Array *streamIndexArray;
  NSMutableArray *peerArray;
} Camera__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = GPBStringifySymbol(UUID),
        .number = Camera_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Camera__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = Camera_FieldNumber_Description_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Camera__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "location",
        .dataTypeSpecific.className = GPBStringifySymbol(UUID),
        .number = Camera_FieldNumber_Location,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Camera__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "streamArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Camera_Stream),
        .number = Camera_FieldNumber_StreamArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Camera__storage_, streamArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "streamIndexArray",
        .dataTypeSpecific.className = NULL,
        .number = Camera_FieldNumber_StreamIndexArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Camera__storage_, streamIndexArray),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "peerArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Camera_PeerConnector),
        .number = Camera_FieldNumber_PeerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Camera__storage_, peerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Camera class]
                                     rootClass:[DeviceRoot class]
                                          file:DeviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Camera__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Camera_Stream

@implementation Camera_Stream

@dynamic videoURL;
@dynamic controlURL;
@dynamic width;
@dynamic height;
@dynamic depth;
@dynamic fps;
@dynamic bps;
@dynamic format;
@dynamic acceptor;
@dynamic hasAuthorizer, authorizer;
@dynamic index;
@dynamic s3Bucket;

typedef struct Camera_Stream__storage_ {
  uint32_t _has_storage_[1];
  int32_t width;
  int32_t height;
  int32_t depth;
  int32_t fps;
  PixelFormat format;
  int32_t index;
  NSString *videoURL;
  NSString *controlURL;
  UUID *authorizer;
  NSString *s3Bucket;
  int64_t bps;
} Camera_Stream__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "videoURL",
        .dataTypeSpecific.className = NULL,
        .number = Camera_Stream_FieldNumber_VideoURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Camera_Stream__storage_, videoURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "controlURL",
        .dataTypeSpecific.className = NULL,
        .number = Camera_Stream_FieldNumber_ControlURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Camera_Stream__storage_, controlURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = Camera_Stream_FieldNumber_Width,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Camera_Stream__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = Camera_Stream_FieldNumber_Height,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Camera_Stream__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "depth",
        .dataTypeSpecific.className = NULL,
        .number = Camera_Stream_FieldNumber_Depth,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Camera_Stream__storage_, depth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fps",
        .dataTypeSpecific.className = NULL,
        .number = Camera_Stream_FieldNumber_Fps,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Camera_Stream__storage_, fps),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "bps",
        .dataTypeSpecific.className = NULL,
        .number = Camera_Stream_FieldNumber_Bps,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Camera_Stream__storage_, bps),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "format",
        .dataTypeSpecific.enumDescFunc = PixelFormat_EnumDescriptor,
        .number = Camera_Stream_FieldNumber_Format,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Camera_Stream__storage_, format),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "acceptor",
        .dataTypeSpecific.className = NULL,
        .number = Camera_Stream_FieldNumber_Acceptor,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "authorizer",
        .dataTypeSpecific.className = GPBStringifySymbol(UUID),
        .number = Camera_Stream_FieldNumber_Authorizer,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Camera_Stream__storage_, authorizer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = Camera_Stream_FieldNumber_Index,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Camera_Stream__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "s3Bucket",
        .dataTypeSpecific.className = NULL,
        .number = Camera_Stream_FieldNumber_S3Bucket,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Camera_Stream__storage_, s3Bucket),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Camera_Stream class]
                                     rootClass:[DeviceRoot class]
                                          file:DeviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Camera_Stream__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\005\241!!\000\002\007\241!!\000\014\002&\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Camera_Stream_Format_RawValue(Camera_Stream *message) {
  GPBDescriptor *descriptor = [Camera_Stream descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Camera_Stream_FieldNumber_Format];
  return GPBGetMessageInt32Field(message, field);
}

void SetCamera_Stream_Format_RawValue(Camera_Stream *message, int32_t value) {
  GPBDescriptor *descriptor = [Camera_Stream descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Camera_Stream_FieldNumber_Format];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Camera_PeerConnector

@implementation Camera_PeerConnector

@dynamic arrowAngle;
@dynamic arrowX;
@dynamic arrowY;
@dynamic hasCamera, camera;

typedef struct Camera_PeerConnector__storage_ {
  uint32_t _has_storage_[1];
  int32_t arrowAngle;
  float arrowX;
  float arrowY;
  UUID *camera;
} Camera_PeerConnector__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "arrowAngle",
        .dataTypeSpecific.className = NULL,
        .number = Camera_PeerConnector_FieldNumber_ArrowAngle,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Camera_PeerConnector__storage_, arrowAngle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "arrowX",
        .dataTypeSpecific.className = NULL,
        .number = Camera_PeerConnector_FieldNumber_ArrowX,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Camera_PeerConnector__storage_, arrowX),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "arrowY",
        .dataTypeSpecific.className = NULL,
        .number = Camera_PeerConnector_FieldNumber_ArrowY,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Camera_PeerConnector__storage_, arrowY),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "camera",
        .dataTypeSpecific.className = GPBStringifySymbol(UUID),
        .number = Camera_PeerConnector_FieldNumber_Camera,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Camera_PeerConnector__storage_, camera),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Camera_PeerConnector class]
                                     rootClass:[DeviceRoot class]
                                          file:DeviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Camera_PeerConnector__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Clip

@implementation Clip

@dynamic hasId_p, id_p;
@dynamic hasCamera, camera;
@dynamic streamIndex;
@dynamic hasStart, start;
@dynamic hasDuration, duration;
@dynamic storage;
@dynamic hasKeepUntil, keepUntil;

typedef struct Clip__storage_ {
  uint32_t _has_storage_[1];
  int32_t streamIndex;
  UUID *id_p;
  UUID *camera;
  TimeStamp *start;
  TimeDelta *duration;
  NSString *storage;
  TimeStamp *keepUntil;
} Clip__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = GPBStringifySymbol(UUID),
        .number = Clip_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Clip__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "camera",
        .dataTypeSpecific.className = GPBStringifySymbol(UUID),
        .number = Clip_FieldNumber_Camera,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Clip__storage_, camera),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "streamIndex",
        .dataTypeSpecific.className = NULL,
        .number = Clip_FieldNumber_StreamIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Clip__storage_, streamIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(TimeStamp),
        .number = Clip_FieldNumber_Start,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Clip__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = GPBStringifySymbol(TimeDelta),
        .number = Clip_FieldNumber_Duration,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Clip__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "storage",
        .dataTypeSpecific.className = NULL,
        .number = Clip_FieldNumber_Storage,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Clip__storage_, storage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keepUntil",
        .dataTypeSpecific.className = GPBStringifySymbol(TimeStamp),
        .number = Clip_FieldNumber_KeepUntil,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Clip__storage_, keepUntil),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Clip class]
                                     rootClass:[DeviceRoot class]
                                          file:DeviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Clip__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CameraRequest

@implementation CameraRequest

@dynamic cameraArray, cameraArray_Count;
@dynamic hasAuthorizer, authorizer;

typedef struct CameraRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *cameraArray;
  UUID *authorizer;
} CameraRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cameraArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UUID),
        .number = CameraRequest_FieldNumber_CameraArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CameraRequest__storage_, cameraArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authorizer",
        .dataTypeSpecific.className = GPBStringifySymbol(UUID),
        .number = CameraRequest_FieldNumber_Authorizer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CameraRequest__storage_, authorizer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CameraRequest class]
                                     rootClass:[DeviceRoot class]
                                          file:DeviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CameraRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CameraResponse

@implementation CameraResponse

@dynamic cameraArray, cameraArray_Count;
@dynamic status;

typedef struct CameraResponse__storage_ {
  uint32_t _has_storage_[1];
  OwalStatus status;
  NSMutableArray *cameraArray;
} CameraResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cameraArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Camera),
        .number = CameraResponse_FieldNumber_CameraArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CameraResponse__storage_, cameraArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = OwalStatus_EnumDescriptor,
        .number = CameraResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CameraResponse__storage_, status),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CameraResponse class]
                                     rootClass:[DeviceRoot class]
                                          file:DeviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CameraResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CameraResponse_Status_RawValue(CameraResponse *message) {
  GPBDescriptor *descriptor = [CameraResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CameraResponse_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetCameraResponse_Status_RawValue(CameraResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [CameraResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CameraResponse_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ClipRequest

@implementation ClipRequest

@dynamic hasCamera, camera;
@dynamic hasFirst, first;
@dynamic hasDuration, duration;
@dynamic hasAuthorizer, authorizer;

typedef struct ClipRequest__storage_ {
  uint32_t _has_storage_[1];
  UUID *camera;
  TimeStamp *first;
  TimeDelta *duration;
  UUID *authorizer;
} ClipRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "camera",
        .dataTypeSpecific.className = GPBStringifySymbol(UUID),
        .number = ClipRequest_FieldNumber_Camera,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClipRequest__storage_, camera),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "first",
        .dataTypeSpecific.className = GPBStringifySymbol(TimeStamp),
        .number = ClipRequest_FieldNumber_First,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClipRequest__storage_, first),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = GPBStringifySymbol(TimeDelta),
        .number = ClipRequest_FieldNumber_Duration,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ClipRequest__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authorizer",
        .dataTypeSpecific.className = GPBStringifySymbol(UUID),
        .number = ClipRequest_FieldNumber_Authorizer,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ClipRequest__storage_, authorizer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClipRequest class]
                                     rootClass:[DeviceRoot class]
                                          file:DeviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClipRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClipResponse

@implementation ClipResponse

@dynamic clipArray, clipArray_Count;
@dynamic status;

typedef struct ClipResponse__storage_ {
  uint32_t _has_storage_[1];
  OwalStatus status;
  NSMutableArray *clipArray;
} ClipResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clipArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Clip),
        .number = ClipResponse_FieldNumber_ClipArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ClipResponse__storage_, clipArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = OwalStatus_EnumDescriptor,
        .number = ClipResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClipResponse__storage_, status),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClipResponse class]
                                     rootClass:[DeviceRoot class]
                                          file:DeviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClipResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ClipResponse_Status_RawValue(ClipResponse *message) {
  GPBDescriptor *descriptor = [ClipResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ClipResponse_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetClipResponse_Status_RawValue(ClipResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [ClipResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ClipResponse_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
